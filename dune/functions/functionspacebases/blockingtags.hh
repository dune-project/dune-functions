// -*- tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 2 -*-
// vi: set et ts=4 sw=2 sts=2:
#ifndef DUNE_FUNCTIONS_FUNCTIONSPACEBASES_BLOCKINGTAGS_HH
#define DUNE_FUNCTIONS_FUNCTIONSPACEBASES_BLOCKINGTAGS_HH

#include <tuple>
#include <type_traits>

#include <dune/common/indices.hh>

namespace Dune {

//! Lightweight representation of (hierarchic) blocking structure
/**
 * The blocking structure can be used to define types for data-structures, like vectors
 * or matrices, that can be accessed by the multi-indices provided by a basis.
 **/
namespace BlockingTag {

  //! Blocking structure that is neither Flat, LeafBlocked, nor Blocked.
  struct Unknown {};

  //! Blocking structure for containers that can be accessed by flat multiindices or the
  //! last index in a multi-index, respectively. In case of multi-indices generated by
  //! index-merging strategies, it corresponds to FlatLexicographic or FlatInterleaved.
  struct Flat
  {
    template <class Index>
    constexpr Flat operator[](const Index&) const { return {}; }
  };

  //! Blocking structure for containers with fixed-size block element types that can be
  //! accessed by multi-indices of size >= 2. In case of multi-indices generated by
  //! index-merging strategies, it corresponds to BlockedInterleaved.
  template <std::size_t N>
  struct LeafBlocked
  {
    template <class Index>
    constexpr Flat operator[](const Index&) const { return {}; }
  };

  //! Blocking structure for containers with a nested hierarchy. In case of multi-indices
  //! generated by index-merging strategies, it corresponds to BlockedLexicographic.
  template <class Tag0, class... Tags>
  struct Blocked
  {
    //! Obtain the ith sub blocking structure
    template <std::size_t i>
    constexpr auto operator[](index_constant<i>) const { return std::get<i>(t); }

    //! In case all blocks have the same structure, return the first blocking tag.
    constexpr Tag0 operator[](std::size_t /*i*/) const { return {}; }

    std::tuple<Tag0,Tags...> t;
  };


  namespace Impl_
  {
    template <class Tag, class Seq>
    struct PowerBlocked;

    template <class Tag, std::size_t... n>
    struct PowerBlocked<Tag, std::index_sequence<n...>>
    {
      template <std::size_t i>
      using expand = Tag;

      using type = Dune::BlockingTag::Blocked<expand<n>...>;
    };
  }

  // helper type for repeated tags in a blocking
  template <class Tag, std::size_t n>
  using PowerBlocked = typename Impl_::PowerBlocked<Tag, std::make_index_sequence<n>>::type;

}} // end namespace Dune::BlockingTag

#endif // DUNE_FUNCTIONS_FUNCTIONSPACEBASES_BLOCKINGTAGS_HH
